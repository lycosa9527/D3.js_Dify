<!DOCTYPE html>
<html lang="en">
<head>
    <title>MindGraph - Diagram Generator</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="UTF-8">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>📊</text></svg>">
    <style>
        /* Reset and Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: #2d3748;
            line-height: 1.6;
            min-height: 100vh;
        }

        /* Container and Layout */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        .main-card {
            background: #ffffff;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.08);
            overflow: hidden;
            margin-bottom: 2rem;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2.5rem 2rem;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            letter-spacing: -0.025em;
        }

        .header p {
            font-size: 1.1rem;
            font-weight: 300;
            opacity: 0.9;
        }

        .content {
            padding: 2.5rem 2rem;
        }

        /* Form Elements */
        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-group label {
            display: block;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 0.5rem;
            font-size: 0.95rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Form Row Layout */
        .form-row {
            display: flex;
            align-items: flex-end;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .language-selector {
            flex-shrink: 0;
            min-width: 200px;
        }

        .language-selector label {
            display: block;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 0.5rem;
            font-size: 0.95rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .language-selector .form-control {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 0.95rem;
            font-family: inherit;
            transition: all 0.2s ease;
            background: #fafbfc;
            cursor: pointer;
        }

        .language-selector .form-control:focus {
            outline: none;
            border-color: #667eea;
            background: #ffffff;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .form-control {
            width: 100%;
            padding: 1rem 1.25rem;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 1rem;
            font-family: inherit;
            transition: all 0.2s ease;
            background: #fafbfc;
        }

        .form-control:focus {
            outline: none;
            border-color: #667eea;
            background: #ffffff;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        textarea.form-control {
            min-height: 80px;
            resize: vertical;
            line-height: 1.5;
        }

        select.form-control {
            cursor: pointer;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.75rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
            appearance: none;
        }

        /* Button Styles */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 1rem 2rem;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            font-family: inherit;
            min-height: 3rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:active {
            transform: translateY(0);
        }

        .btn-primary:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Status Messages */
        .status-message {
            padding: 1rem 1.25rem;
            border-radius: 12px;
            margin: 1rem 0;
            font-weight: 500;
            display: none;
        }

        .status-info {
            background: #ebf8ff;
            color: #2b6cb0;
            border: 1px solid #bee3f8;
        }

        .status-error {
            background: #fed7d7;
            color: #c53030;
            border: 1px solid #feb2b2;
        }

        .status-success {
            background: #f0fff4;
            color: #2f855a;
            border: 1px solid #c6f6d5;
        }

        /* Results Display */
        .result-container {
            margin-top: 2rem;
            display: none;
        }

        .result-card {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 16px;
            padding: 1.5rem;
            margin-bottom: 1rem;
        }

        .result-card h3 {
            color: #4a5568;
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* PNG Display */
        .png-container {
            background: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 16px;
            padding: 1.5rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }

        .png-container img {
            max-width: 100%;
            height: auto;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .png-container img:hover {
            transform: scale(1.02);
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.15);
        }

        .png-container img.expanded {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(1.5);
            z-index: 1000;
            background: white;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            cursor: zoom-out;
            border-radius: 16px;
        }

        .png-note {
            margin-top: 1rem;
            padding: 0.75rem 1rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 12px;
            font-size: 0.9rem;
            font-weight: 500;
            text-align: center;
        }

        /* History Display */
        .history-container {
            margin-top: 1rem;
        }



        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .header {
                padding: 2rem 1.5rem;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .content {
                padding: 2rem 1.5rem;
            }
            
            .form-row {
                flex-direction: column;
                align-items: stretch;
                gap: 1rem;
            }
            
            .language-selector {
                min-width: auto;
            }
            
            .btn {
                width: 100%;
                margin-top: 0;
            }
        }

        /* Loading States */
        .loading {
            opacity: 0.7;
            pointer-events: none;
        }

        .loading .btn-primary {
            background: #cbd5e0;
        }

        /* Smooth Transitions */
        .fade-in {
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-card">
            <div class="header">
                <h1>MindGraph</h1>
                <p>Professional Diagram Generation Tool</p>
            </div>
            
            <div class="content">
                <div class="form-group">
                    <label for="prompt">Diagram Prompt</label>
                    <textarea id="prompt" class="form-control" placeholder="Describe the diagram you want to create..."></textarea>
                </div>
                
                <div class="form-row">
                    <div class="language-selector">
                        <label for="language">Language</label>
                        <select id="language" class="form-control">
                            <option value="zh">中文 (Chinese)</option>
                            <option value="en">English</option>
                        </select>
                    </div>
                    
                    <button id="generateDiagramBtn" class="btn btn-primary">
                        Generate Diagram
                    </button>
                </div>
                
                <div id="infoMsg" class="status-message status-info"></div>
                <div id="errorMsg" class="status-message status-error"></div>
                
                <div class="history-container" id="historyBox"></div>
                
                <div class="result-container" id="jsonResult"></div>
                <div class="result-container" id="pngResult"></div>
                

            </div>
        </div>
    </div>


    
    <!-- UNIFIED RENDERING PIPELINE SYSTEM -->
    <script>
        // Module mapping for different graph types
        const graphTypeModules = {
            'tree_map': ['theme-config', 'style-manager', 'shared-utilities', 'tree-renderer', 'renderer-dispatcher'],
            'mindmap': ['theme-config', 'style-manager', 'shared-utilities', 'mind-map-renderer', 'renderer-dispatcher'],
            'concept_map': ['theme-config', 'style-manager', 'shared-utilities', 'concept-map-renderer', 'renderer-dispatcher'],
            'bubble_map': ['theme-config', 'style-manager', 'shared-utilities', 'bubble-map-renderer', 'renderer-dispatcher'],
            'double_bubble_map': ['theme-config', 'style-manager', 'shared-utilities', 'bubble-map-renderer', 'renderer-dispatcher'],
            'flow_map': ['theme-config', 'style-manager', 'shared-utilities', 'flow-renderer', 'renderer-dispatcher'],
            'multi_flow_map': ['theme-config', 'style-manager', 'shared-utilities', 'flow-renderer', 'renderer-dispatcher'],

            'brace_map': ['theme-config', 'style-manager', 'shared-utilities', 'brace-renderer', 'renderer-dispatcher']
        };
        
        // Track loaded modules to prevent duplicates
        const loadedModules = new Set();
        
        // PROMISE-BASED MODULE LOADING - FIXES TIMING ISSUES
        function loadRequiredModules(graphType) {
            return new Promise((resolve, reject) => {
                console.log(`Loading modules for: ${graphType}`);
                
                const requiredModules = graphTypeModules[graphType] || [];
                if (requiredModules.length === 0) {
                    reject(new Error(`No module mapping found for: ${graphType}`));
                    return;
                }
                
                console.log(`Required modules: ${requiredModules.join(', ')}`);
                
                // Load modules sequentially with proper error handling
                loadModulesSequentially(requiredModules, 0, resolve, reject);
            });
        }
        
        // Load modules one by one with proper error handling
        function loadModulesSequentially(modules, index, resolve, reject) {
            if (index >= modules.length) {
                console.log('All modules loaded successfully!');
                // CRITICAL FIX: Add delay to ensure proper initialization
                setTimeout(() => {
                    console.log('Waiting for module initialization...');
                    resolve();
                }, 100);
                return;
            }
            
            const moduleName = modules[index];
            const modulePath = getModulePath(moduleName);
            
            if (loadedModules.has(moduleName)) {
                console.log(`${moduleName} already loaded, skipping...`);
                loadModulesSequentially(modules, index + 1, resolve, reject);
                return;
            }
            
            console.log(`Loading module ${index + 1}/${modules.length}: ${moduleName}`);
            
            const script = document.createElement('script');
            script.src = modulePath;
            script.onload = function() {
                console.log(`${moduleName} loaded successfully`);
                loadedModules.add(moduleName);
                // CRITICAL FIX: Add delay between module loads to prevent race conditions
                setTimeout(() => {
                    loadModulesSequentially(modules, index + 1, resolve, reject);
                }, 50);
            };
            script.onerror = function() {
                console.error(`❌ Failed to load ${moduleName} from ${modulePath}`);
                // CRITICAL FIX: Stop loading if core modules fail
                if (['theme-config', 'style-manager', 'shared-utilities'].includes(moduleName)) {
                    reject(new Error(`Critical module ${moduleName} failed to load`));
                    return;
                }
                // Continue loading other modules for non-critical failures
                loadModulesSequentially(modules, index + 1, resolve, reject);
            };
            document.head.appendChild(script);
        }
        
        // Get the correct path for each module
        function getModulePath(moduleName) {
            const modulePaths = {
                'theme-config': '/static/js/theme-config.js',
                'style-manager': '/static/js/style-manager.js',
                'shared-utilities': '/static/js/renderers/shared-utilities.js',
                'tree-renderer': '/static/js/renderers/tree-renderer.js',
                'mind-map-renderer': '/static/js/renderers/mind-map-renderer.js',
                'concept-map-renderer': '/static/js/renderers/concept-map-renderer.js',
                'bubble-map-renderer': '/static/js/renderers/bubble-map-renderer.js',
                'flow-renderer': '/static/js/renderers/flow-renderer.js',

                'brace-renderer': '/static/js/renderers/brace-renderer.js',
                'renderer-dispatcher': '/static/js/renderers/renderer-dispatcher.js'
            };
            
            return modulePaths[moduleName] || `/static/js/renderers/${moduleName}.js`;
        }
        
        // UNIFIED FUNCTION VALIDATION - FIXES RACE CONDITIONS
        function validateFunctions(graphType) {
            console.log(`Validating functions for ${graphType}...`);
            
            const requiredFunctions = {
                'renderGraph': typeof renderGraph
            };
            
            // Add renderer-specific functions
            switch(graphType) {
                case 'tree_map':
                    console.log('Checking tree_map function availability...');
                    console.log('  - window.renderTreeMap:', typeof window.renderTreeMap);
                    console.log('  - window.TreeRenderer:', typeof window.TreeRenderer);
                    console.log('  - window.TreeRenderer?.renderTreeMap:', typeof window.TreeRenderer?.renderTreeMap);
                    
                    // CRITICAL FIX: Check all possible locations for the functions
                    console.log('Global scope check:');
                    console.log('  - renderTreeMap (global):', typeof renderTreeMap);
                    console.log('  - TreeRenderer (global):', typeof TreeRenderer);
                    
                    // Check if functions exist in different scopes
                    if (typeof window.renderTreeMap === 'function') {
                        console.log('window.renderTreeMap is available');
                    } else {
                        console.log('window.renderTreeMap is NOT available');
                    }
                    
                    if (typeof window.TreeRenderer === 'object' && window.TreeRenderer) {
                        console.log('window.TreeRenderer is available');
                        if (typeof window.TreeRenderer.renderTreeMap === 'function') {
                            console.log('window.TreeRenderer.renderTreeMap is available');
                        } else {
                            console.log('window.TreeRenderer.renderTreeMap is NOT available');
                        }
                    } else {
                        console.log('window.TreeRenderer is NOT available');
                    }
                    
                    requiredFunctions.renderTreeMap = typeof window.renderTreeMap;
                    requiredFunctions.TreeRenderer = typeof window.TreeRenderer;
                    // Also check if functions are available in the TreeRenderer object
                    if (typeof window.TreeRenderer === 'object' && window.TreeRenderer) {
                        requiredFunctions.TreeRendererRenderTreeMap = typeof window.TreeRenderer.renderTreeMap;
                    }
                    break;
                case 'mindmap':
                    requiredFunctions.renderMindMap = typeof renderMindMap;
                    break;
                case 'concept_map':
                    requiredFunctions.renderConceptMap = typeof renderConceptMap;
                    break;
                case 'bubble_map':
                    requiredFunctions.renderBubbleMap = typeof renderBubbleMap;
                    break;
                case 'flow_map':
                    requiredFunctions.renderFlowMap = typeof renderFlowMap;
                    break;

                case 'brace_map':
                    requiredFunctions.renderBraceMap = typeof renderBraceMap;
                    break;
            }
            
            const missingFunctions = Object.entries(requiredFunctions)
                .filter(([name, type]) => type === 'undefined')
                .map(([name]) => name);
            
            if (missingFunctions.length > 0) {
                console.error(`❌ Missing required functions: ${missingFunctions.join(', ')}`);
                return false;
            }
            
            console.log('All required functions are available');
            return true;
        }
        
        // UNIFIED RENDERING FUNCTION - FIXES DUAL PIPELINE CONFLICT
        async function renderDiagram(graphType, data) {
            try {
                console.log(`Starting unified rendering for ${graphType}...`);
                
                // 1. Load required modules first (PROACTIVE LOADING)
                await loadRequiredModules(graphType);
                
                // 2. Add extra delay for tree_map to ensure proper initialization
                if (graphType === 'tree_map') {
                    console.log('Tree map detected, adding extra initialization delay...');
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
                
                // 3. Validate functions are available
                if (!validateFunctions(graphType)) {
                    // CRITICAL FIX: For tree_map, try to manually check and fix function availability
                    if (graphType === 'tree_map') {
                        console.log('Attempting to fix tree_map function availability...');
                        await attemptTreeMapFunctionFix();
                        
                        // Re-validate after fix attempt
                        if (!validateFunctions(graphType)) {
                            throw new Error('Required functions not available after module loading and fix attempt');
                        }
                    } else {
                        throw new Error('Required functions not available after module loading');
                    }
                }
                
                // 4. Prepare theme and dimensions
                const theme = prepareTheme(data, graphType);
                const dimensions = data.dimensions || {};
                
                // 5. Clear previous D3 visualization
                const d3Container = document.getElementById('d3-container');
                if (d3Container) {
                    d3Container.innerHTML = '';
                    console.log('Cleared previous D3 visualization');
                }
                
                // 6. Render the diagram
                console.log('Calling renderGraph...');
                renderGraph(graphType, data.spec, theme, dimensions);
                
                console.log('Diagram rendered successfully!');
                return true;
                
            } catch (error) {
                console.error('❌ Rendering failed:', error);
                throw error;
            }
        }
        
        // CRITICAL FIX: Function to attempt fixing tree_map function availability
        async function attemptTreeMapFunctionFix() {
            console.log('Attempting to fix tree_map function availability...');
            
            // CRITICAL FIX: Check script loading status
            console.log('Checking script loading status...');
            const scripts = document.querySelectorAll('script[src*="tree-renderer"]');
            console.log('Found tree-renderer scripts:', scripts.length);
            scripts.forEach((script, index) => {
                console.log(`  Script ${index}:`, script.src, 'Loaded:', script.complete);
            });
            
            // Check if functions exist in different scopes
            const functionChecks = [
                { name: 'window.renderTreeMap', func: window.renderTreeMap },
                { name: 'window.TreeRenderer.renderTreeMap', func: window.TreeRenderer?.renderTreeMap }
            ];
            
            for (const check of functionChecks) {
                if (typeof check.func === 'function') {
                                            console.log(`Found ${check.name}:`, check.func);
                    
                    // Try to expose it globally if not already there
                    if (check.name === 'window.renderTreeMap' && typeof window.renderTreeMap === 'function') {
                        if (typeof window.renderTreeMap !== 'function') {
                            window.renderTreeMap = window.renderTreeMap;
                            console.log('Exposed window.renderTreeMap to global scope');
                        }
                    }
                    
                    if (check.name === 'window.TreeRenderer.renderTreeMap' && window.TreeRenderer?.renderTreeMap) {
                        if (typeof window.TreeRenderer !== 'object') {
                            window.TreeRenderer = window.TreeRenderer;
                            console.log('Exposed window.TreeRenderer to global scope');
                        }
                    }
                } else {
                                            console.log(`${check.name} not available:`, typeof check.func);
                }
            }
            
            // CRITICAL FIX: Try to manually trigger the export if it failed
            console.log('Attempting manual function exposure...');
            try {
                // Check if the tree-renderer script has executed but failed to export
                if (typeof window.renderTreeMap === 'undefined' && typeof window.TreeRenderer === 'undefined') {
                    console.log('No functions found, checking if script execution completed...');
                    
                    // Wait a bit more and check again
                    await new Promise(resolve => setTimeout(resolve, 200));
                    
                    if (typeof window.renderTreeMap === 'undefined' && typeof window.TreeRenderer === 'undefined') {
                        console.error('CRITICAL: Tree renderer functions still not available after delay');
                        console.error('This suggests the tree-renderer.js script failed to execute properly');
                    }
                }
            } catch (error) {
                                    console.error('Error during manual function exposure:', error);
            }
            
            // Wait a bit more for any async operations
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // Theme preparation function
        function prepareTheme(data, graphType) {
            const stylePreferences = data.style_preferences || {};
            const backendTheme = data.theme || {};
            const backendWatermark = data.watermark || {};
            
            // Use centralized theme configuration if available
            let baseTheme;
            if (typeof getD3Theme === 'function') {
                baseTheme = getD3Theme(graphType);
                console.log('Using centralized theme configuration');
            } else if (typeof styleManager !== 'undefined') {
                baseTheme = styleManager.getTheme(graphType, {});
                console.log('Using style manager theme');
            } else {
                baseTheme = {};
                console.warn('No theme system available, using defaults');
            }
            
            // Merge themes in priority order
            const finalTheme = { 
                ...baseTheme, 
                ...backendTheme, 
                ...convertStylePreferencesToTheme(stylePreferences) 
            };
            
            // Add watermark if provided
            if (backendWatermark.watermarkText) {
                finalTheme.watermarkText = backendWatermark.watermarkText;
            }
            
            console.log('Final theme:', finalTheme);
            return finalTheme;
        }
        
        // Monitor server-generated inline scripts
        function monitorInlineScripts() {
            console.log('Monitoring for server-generated inline scripts...');
            
            // Use MutationObserver to watch for new script tags
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    mutation.addedNodes.forEach(function(node) {
                        if (node.nodeType === Node.ELEMENT_NODE && node.tagName === 'SCRIPT') {
                            if (node.hasAttribute('data-module')) {
                                console.log(`New inline script detected: ${node.getAttribute('data-module')}`);
                                monitorScriptExecution(node);
                            }
                        }
                    });
                });
            });
            
            // Start observing
            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
            
            // Also check existing scripts
            const existingScripts = document.querySelectorAll('script[data-module]');
            console.log(`Found ${existingScripts.length} existing inline scripts`);
            existingScripts.forEach(monitorScriptExecution);
        }
        
        // Monitor individual script execution
        function monitorScriptExecution(script) {
            const moduleName = script.getAttribute('data-module');
            console.log(`Monitoring script: ${moduleName}`);
            
            // Check if script has content
            const content = script.textContent || script.innerHTML;
            if (content.trim().length === 0) {
                console.error(`❌ Script ${moduleName} has no content!`);
                return;
            }
            
                            console.log(`Script ${moduleName} has content (${content.length} chars)`);
            
            // Monitor execution by checking function availability after a delay
            setTimeout(() => {
                checkFunctionAvailability(moduleName);
            }, 100);
        }
        
        // Check function availability for a specific module
        function checkFunctionAvailability(moduleName) {
                            console.log(`Checking functions for ${moduleName}...`);
            
            let functions = {};
            switch(moduleName) {
                case 'tree-renderer':
                    functions = {
                        'renderTreeMap': typeof renderTreeMap,
                        'TreeRenderer': typeof TreeRenderer
                    };
                    break;
                case 'shared-utilities':
                    functions = {
                        'MindGraphUtils': typeof MindGraphUtils,
                        'addWatermark': typeof addWatermark
                    };
                    break;
                case 'renderer-dispatcher':
                    functions = {
                        'renderGraph': typeof renderGraph
                    };
                    break;
            }
            
            Object.entries(functions).forEach(([funcName, funcType]) => {
                if (funcType === 'undefined') {
                    console.warn(`⚠️ ${funcName} not available after ${moduleName} execution`);
                } else {
                    console.log(`${funcName} available: ${funcType}`);
                }
            });
        }
        

        
        // Load modules when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Debug page loaded');
            
            // Start monitoring for inline scripts
            monitorInlineScripts();
        });
    </script>
    
    <script>
    const generateDiagramBtn = document.getElementById('generateDiagramBtn');
    const promptBox = document.getElementById('prompt');
    const languageSelect = document.getElementById('language');
    const jsonResult = document.getElementById('jsonResult');
    const pngResult = document.getElementById('pngResult');
    const errorMsg = document.getElementById('errorMsg');
    const infoMsg = document.getElementById('infoMsg');
    const historyBox = document.getElementById('historyBox');
    

    


    // --- History logic ---
    let history = JSON.parse(localStorage.getItem('mindgraph_history') || '[]');
    function saveHistory(prompt, lang) {
        if (!prompt.trim()) return;
        history = history.filter(h => h.prompt !== prompt || h.lang !== lang);
        history.unshift({prompt, lang});
        if (history.length > 10) history = history.slice(0, 10);
        localStorage.setItem('mindgraph_history', JSON.stringify(history));
        renderHistory();
    }
    function renderHistory() {
        if (!history.length) { 
            historyBox.innerHTML = ''; 
            return; 
        }
        
        // Simple, compact history display like old debug.html
        const historyTitle = document.createElement('div');
        historyTitle.innerHTML = '<b>Recent Prompts:</b>';
        historyTitle.style.marginBottom = '0.5rem';
        historyTitle.style.color = '#4a5568';
        historyTitle.style.fontSize = '0.9rem';
        
        const historyList = history.map((h, i) => {
            const item = document.createElement('div');
            item.style.cssText = 'margin: 4px 0; font-size: 0.9rem;';
            
            const link = document.createElement('a');
            link.href = '#';
            link.style.cssText = 'color: #4e79a7; text-decoration: underline; cursor: pointer;';
            link.textContent = h.prompt;
            link.onclick = (e) => {
                e.preventDefault();
                promptBox.value = h.prompt;
                languageSelect.value = h.lang;
            };
            
            const lang = document.createElement('span');
            lang.style.cssText = 'color: #888; font-size: 0.8em; margin-left: 8px;';
            lang.textContent = `[${h.lang}]`;
            
            item.appendChild(link);
            item.appendChild(lang);
            
            return item;
        });
        
        historyBox.innerHTML = '';
        historyBox.appendChild(historyTitle);
        historyList.forEach(item => historyBox.appendChild(item));
    }

    renderHistory();
    
    // Debug: Ensure history panel is visible
    console.log('History panel initialized');
    console.log('History items:', history.length);

    // --- Style conversion and application ---
    function convertStylePreferencesToTheme(stylePreferences) {
        // Convert style preferences to theme object without dependencies
        const userTheme = {
            colorTheme: stylePreferences.color_theme,
            topicFill: stylePreferences.primary_color ? getColorFromName(stylePreferences.primary_color) : null,
            fontTopic: stylePreferences.font_size ? getFontSizeFromName(stylePreferences.font_size) + 4 : null,
            fontAttribute: stylePreferences.font_size ? getFontSizeFromName(stylePreferences.font_size) : null,
            background: stylePreferences.background === 'dark' ? '#2d3748' : 
                       stylePreferences.background === 'light' ? '#ffffff' : null,
            topicStrokeWidth: stylePreferences.stroke === 'bold' ? 4 : 
                             stylePreferences.stroke === 'thin' ? 1 : null,
            attributeStrokeWidth: stylePreferences.stroke === 'bold' ? 3 : 
                                 stylePreferences.stroke === 'thin' ? 1 : null
        };
        
        // Return the raw theme object - let prepareTheme handle styleManager integration
        return userTheme;
    }
    
    function getColorFromName(colorName) {
        const colorMap = {
            'red': '#e15759',
            'blue': '#4e79a7',
            'green': '#59a14f',
            'yellow': '#f28e2c',
            'purple': '#b07aa1',
            'orange': '#ff9da7',
            'pink': '#ff9da7',
            'brown': '#9c755f',
            'gray': '#bab0ab',
            'black': '#4a4a4a',
            'white': '#ffffff'
        };
        return colorMap[colorName.toLowerCase()] || null;
    }
    
    function getFontSizeFromName(sizeName) {
        const fontSizeMap = {
            'small': 12,
            'medium': 14,
            'large': 16,
            'extra-large': 18
        };
        return fontSizeMap[sizeName.toLowerCase()] || 14;
    }
    


    function showError(msg) {
        errorMsg.textContent = msg;
        errorMsg.style.display = msg ? 'block' : 'none';
        if (msg) {
            errorMsg.classList.add('fade-in');
        }
    }
    
    function showInfo(msg) {
        infoMsg.textContent = msg;
        infoMsg.style.display = msg ? 'block' : 'none';
        if (msg) {
            infoMsg.classList.add('fade-in');
        }
    }
    
    function showSuccess(msg) {
        const successMsg = document.createElement('div');
        successMsg.className = 'status-message status-success fade-in';
        successMsg.textContent = msg;
        
        const content = document.querySelector('.content');
        content.insertBefore(successMsg, content.firstChild);
        
        // Auto-remove after 3 seconds
        setTimeout(() => {
            successMsg.remove();
        }, 3000);
    }
    function showJsonResult(data) {
        jsonResult.style.display = 'block';
        pngResult.style.display = 'none';
        
        const resultCard = document.createElement('div');
        resultCard.className = 'result-card fade-in';
        
        const title = document.createElement('h3');
        title.innerHTML = '📊 Graph Specification';
        
        const content = document.createElement('pre');
        content.style.cssText = 'background: #f1f5f9; padding: 1rem; border-radius: 8px; overflow-x: auto; font-size: 0.9rem; line-height: 1.4; color: #334155;';
        content.textContent = JSON.stringify(data, null, 2);
        
        resultCard.appendChild(title);
        resultCard.appendChild(content);
        
        jsonResult.innerHTML = '';
        jsonResult.appendChild(resultCard);
    }

    function showPngResult(blob) {
        jsonResult.style.display = 'none';
        pngResult.style.display = 'block';
        pngResult.innerHTML = '';
        
        // Create PNG container with proper styling
        const pngContainer = document.createElement('div');
        pngContainer.className = 'png-container';
        
        // Create image element
        const img = document.createElement('img');
        
        // Create blob URL for display
        const url = URL.createObjectURL(blob);
        img.src = url;
        
        // Clean up blob URL when image loads
        img.onload = () => {
            URL.revokeObjectURL(url);
        };
        
        // Add click-to-expand functionality
        img.addEventListener('click', function() {
            if (this.classList.contains('expanded')) {
                this.classList.remove('expanded');
                document.body.style.overflow = '';
            } else {
                this.classList.add('expanded');
                document.body.style.overflow = 'hidden';
            }
        });
        
        // Add escape key support for expanded image
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && img.classList.contains('expanded')) {
                img.classList.remove('expanded');
                document.body.style.overflow = '';
            }
        });
        
        pngContainer.appendChild(img);
        
        // Add download button and note
        const controls = document.createElement('div');
        controls.style.cssText = 'margin-top: 1rem; display: flex; gap: 0.5rem; justify-content: center; align-items: center;';
        
        // Download button
        const downloadBtn = document.createElement('button');
        downloadBtn.className = 'btn';
        downloadBtn.style.cssText = 'background: #48bb78; color: white; padding: 0.5rem 1rem; border: none; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem;';
        downloadBtn.textContent = 'Download PNG';
        downloadBtn.onclick = () => {
            const downloadUrl = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = downloadUrl;
            a.download = 'mindgraph-diagram.png';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(downloadUrl);
        };
        
        // Open in new tab button (with proper handling)
        const openTabBtn = document.createElement('button');
        openTabBtn.className = 'btn';
        openTabBtn.style.cssText = 'background: #4299e1; color: white; padding: 0.5rem 1rem; border: none; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem;';
        openTabBtn.textContent = 'Open in New Tab';
        openTabBtn.onclick = () => {
            // Create a new blob URL specifically for the new tab
            const newTabUrl = URL.createObjectURL(blob);
            const newTab = window.open(newTabUrl, '_blank');
            
            // Clean up the URL after the new tab opens
            setTimeout(() => {
                URL.revokeObjectURL(newTabUrl);
            }, 1000);
        };
        
        controls.appendChild(downloadBtn);
        controls.appendChild(openTabBtn);
        pngContainer.appendChild(controls);
        
        // Add a note about PNG generation
        const note = document.createElement('div');
        note.className = 'png-note';
        note.innerHTML = '<strong>PNG Generated Successfully!</strong> Use the buttons above to download or view in new tab.';
        pngContainer.appendChild(note);
        
        pngResult.appendChild(pngContainer);
    }
    

    
        // Single Generate Diagram button handler
    generateDiagramBtn.onclick = async function() {
        showError(''); 
        showInfo('Generating diagram...');
        jsonResult.style.display = 'none'; 
        pngResult.style.display = 'none';
        
        try {
            // Get diagram data
            showInfo('Getting diagram data...');
            const resp = await fetch('/api/generate_graph', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ prompt: promptBox.value, language: languageSelect.value })
            });
            
            if (!resp.ok) {
                const errorData = await resp.json().catch(() => ({}));
                showError(errorData.error || 'Failed to generate diagram.');
                showInfo('');
                return;
            }
            
            const data = await resp.json();
            if (!data || !data.spec || !data.type) {
                showError('Invalid diagram data received.');
                showInfo('');
                return;
            }
            

            
            // Skip D3 rendering since we only need PNG
            showInfo('Generating PNG directly...');
            try {
                const pngResp = await fetch('/api/generate_png', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt: promptBox.value, language: languageSelect.value })
                });
                
                if (pngResp.ok) {
                    const pngBlob = await pngResp.blob();
                    showPngResult(pngBlob);
                    showSuccess('PNG generated successfully!');
                } else {
                    const errorData = await pngResp.json().catch(() => ({}));
                    showError('PNG generation failed: ' + (errorData.error || 'Unknown error'));
                }
            } catch (pngError) {
                showError('PNG generation failed: ' + pngError);
            }
            
            showInfo('');
            saveHistory(promptBox.value, languageSelect.value);
            
        } catch (e) {
            showError('Failed to generate diagram: ' + e);
            showInfo('');
        }
    };
    

    </script>
</body>
</html> 